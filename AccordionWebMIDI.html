<!-- 
  /*******************************************************************************
  AccordionWebMIDI.html
  
  MIDI Accordion Visualizer - Web-MIDI App
  https://github.com/BarryKVibes/WebMIDIAccordionVisualizer
  Copyright 2023, Barry K Vibes
  
 *******************************************************************************
  
  MIDI Accordion Visualizer - Web-MIDI App is free software: you can redistribute it and/or 
  modify it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  MIDI Accordion Visualizer - Web-MIDI App is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License along 
  with MIDI Accordion Visualizer - Web-MIDI App. If not, see <https://www.gnu.org/licenses/>.
  
 ******************************************************************************/
 -->

<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>AccordionWebMIDI</title>
  <style>
    .circle {
      display: inline-block;
      border-radius: 50%;
      border: 1px solid black;
      width: 10px;
      height: 10px;
      text-align: center;
      font-size: 12px;
      margin: 2px;
    }

    .active {
      background-color: black;
      color: white;
    }
    .circle.highlight {
  fill: yellow;
}
  </style>
</head>

<body>
  <h1>AccordionWebMIDI</h1>
  <div>
    <h2>Right-hand Notes</h2>
    <div id="rightHandCircles">
    </div>
  </div>
  <div>
    <h2>Left-hand Single Bass Notes</h2>
    <div id="leftHandSingleBassCircles">
    </div>
  </div>
  <div>
    <h2>Left-hand Chord Notes</h2>
    <div id="leftHandChordCircles">
    </div>
  </div>
  <div id="accordion"></div>
  <script>

    // 220304 - Based on code generated by ChatGPT. WORK IN PROGRESS.

    const MelodyChannel = 0;
    const BassChannel = 1;
    const ChordChannel = 3;
    let channels = [MelodyChannel, BassChannel, ChordChannel];

    let inputs = [];
    let rightHandCircles = [];
    let leftHandSingleBassCircles = []; // 2-D array
    let leftHandChordCircles = []; // 2-D array

    // This variables keep track of which notes are active. ChatGPT added these to prevent hanging notes. Not strictly needed for this application.
    let rightHandNotesActive = [];
    let leftHandSingleBassNotesActive = [];
    let leftHandChordNotesActive = [];

    // MIDI Notes in the Left Hand. Note that each row has duplicate MIDI notes.
    // This implies that when a MIDI note is received, more than one circle will highlight.
    // Also, a chord button actually sends out 3 MIDI notes, so a chord must be interpreted from this in order to highlight the corresponding circles.
    // accordionMidiNotes[0] - Right Hand Notes
    // accordionMidiNotes[1] - Bass Notes
    // accordionMidiNotes[2] - Chord Notes
    const firstRHMidiNote = 53; // F below middle C.

    // The following represent all of the keys and buttons of the accordion.
    const accordionMidiNotes = [
      // 1. Right hand keys
      [firstRHMidiNote + 0, firstRHMidiNote + 1, firstRHMidiNote + 2, firstRHMidiNote + 3, firstRHMidiNote + 4, firstRHMidiNote + 5, firstRHMidiNote + 6, firstRHMidiNote + 7, firstRHMidiNote + 8, firstRHMidiNote + 9, firstRHMidiNote + 10, firstRHMidiNote + 11, firstRHMidiNote + 12, firstRHMidiNote + 13, firstRHMidiNote + 14, firstRHMidiNote + 15, firstRHMidiNote + 16, firstRHMidiNote + 17, firstRHMidiNote + 18, firstRHMidiNote + 19, firstRHMidiNote + 20, firstRHMidiNote + 21, firstRHMidiNote + 22, firstRHMidiNote + 23, firstRHMidiNote + 24, firstRHMidiNote + 25, firstRHMidiNote + 26, firstRHMidiNote + 27, firstRHMidiNote + 28, firstRHMidiNote + 29, firstRHMidiNote + 30, firstRHMidiNote + 31, firstRHMidiNote + 32, firstRHMidiNote + 33, firstRHMidiNote + 34, firstRHMidiNote + 35, firstRHMidiNote + 36, firstRHMidiNote + 37, firstRHMidiNote + 38, firstRHMidiNote + 39, firstRHMidiNote + 40],

      // The following represent the rows of the left hand.
      // 2. Major 3rd above the root.
      [37, 44, 39, 46, 41, 36, 43, 38, 45, 40, 47, 42, 37, 44, 39, 46, 41, 36, 43, 38], // Maj 3rd

      // 3. Root.
      [45, 40, 47, 42, 37, 44, 39, 46, 41, 36, 43, 38, 45, 40, 47, 42, 37, 44, 39, 46], // Root.

      // The following are the 4 rows of triads; Major, Minor, 7th, Diminished.
      ['A', 'E', 'B', 'Gb', 'Db', 'Ab', 'Eb', 'Bb', 'F', 'C', 'G', 'D', 'A', 'E', 'B', 'Gb', 'Db', 'Ab', 'Eb', 'Bb'], // Major
      ['A', 'E', 'B', 'Gb', 'Db', 'Ab', 'Eb', 'Bb', 'F', 'C', 'G', 'D', 'A', 'E', 'B', 'Gb', 'Db', 'Ab', 'Eb', 'Bb'], // Minor
      ['A', 'E', 'B', 'Gb', 'Db', 'Ab', 'Eb', 'Bb', 'F', 'C', 'G', 'D', 'A', 'E', 'B', 'Gb', 'Db', 'Ab', 'Eb', 'Bb'], // Dominant7th
      ['Gb', 'Db', 'Ab', 'Eb', 'Bb', 'F', 'C', 'G', 'D', 'A', 'E', 'B', 'Gb', 'Db', 'Ab', 'Eb', 'Bb', 'F', 'C', 'Gb'] // Diminished
    ];

    // Create an object to map chord names to their corresponding row index.
    const chordRowMap = {
      "major": 0,
      "minor": 1,
      "dominant7th": 2,
      "diminished": 3
    }

    function onMIDISuccess(midiAccess) {
      for (let input of midiAccess.inputs.values()) {
        inputs.push(input);
        input.onmidimessage = onMIDIMessage;
      }
      console.log('MIDI inputs:', inputs);
    }

    function onMIDIFailure(msg) {
      console.log(`Failed to get MIDI access - ${msg}`);
    }

    function onMIDIMessage(event) {
      console.log('MIDI event:', event);
      let command = event.data[0] >> 4;
      let channel = event.data[0] & 0xf;
      let note = event.data[1];
      let velocity = event.data[2];
      if (command === 8 || (command === 9 && velocity === 0)) {
        noteOff(channel, note);
      } else if (command === 9) {
        noteOn(channel, note);
      }
    }

    function updateActiveNotes(channel, note, isNoteOn) {
      let activeNotes;

      switch (channel) {
        case MelodyChannel:
          activeNotes = rightHandNotesActive;
          break;
        case BassChannel:
          activeNotes = leftHandSingleBassNotesActive;
          break;
        case ChordChannel:
          activeNotes = leftHandChordNotesActive;
          break;
      }

      activeNoteIndex = activeNotes.indexOf(note);
      if (isNoteOn) {
        if (activeNoteIndex === -1) {
          activeNotes.push(note);
        }
      }
      else {
        if (activeNoteIndex !== -1) {
          activeNotes.splice(activeNoteIndex, 1);
        }
      }
    }

    function noteOn(channel, note) {

      updateActiveNotes(channel, note, true);

      if (channel === MelodyChannel) {

        let notesInRow = accordionMidiNotes[0];
        let circleIndex = notesInRow.indexOf(note);

        if (circleIndex !== -1) {
          let circle = rightHandCircles[circleIndex];
          circle.classList.add('active');
        }
      } 
      else if (channel === BassChannel) {

        let notesInMajor3rdRow = accordionMidiNotes[1];
        let notesInRootRow = accordionMidiNotes[2];

        let circleIndices = findIndicesOfValue(notesInMajor3rdRow, note);
        for (let i = 0; i < circleIndices.length; i++) {
          let circleIndex = circleIndices[i];
          let circle = leftHandSingleBassCircles[0][circleIndex];
          circle.classList.add('active');
        }

        circleIndices = findIndicesOfValue(notesInRootRow, note);
        for (let i = 0; i < circleIndices.length; i++) {
          let circleIndex = circleIndices[i];
          let circle = leftHandSingleBassCircles[1][circleIndex];
          circle.classList.add('active');
        }
      }
      else if (channel === ChordChannel) {

        if (leftHandChordNotesActive.length < 3) {
          return;
        }

        // TODO: Recognize multiple chords.
        const chord = getChordTypeAndKey(leftHandChordNotesActive);

        console.log(`LH - Chord type: ${chord.chordType}, Key: ${chord.key}`);

        // Highlight the corresponding circles for the active chord.
        highlightChord(chord.chordType, chord.key, true);
      }
    }

    function noteOff(channel, note) {

      switch (channel) {
        case MelodyChannel:
          let notesInChannel = accordionMidiNotes[0];
          let circleIndex = notesInChannel.indexOf(note);
          circle = rightHandCircles[circleIndex];
          circle.classList.remove('active');
          break;

        case BassChannel:

          let notesInMajor3rdRow = accordionMidiNotes[1];
          let notesInRootRow = accordionMidiNotes[2];
          let circleIndices = findIndicesOfValue(notesInMajor3rdRow, note);
          for (let i = 0; i < circleIndices.length; i++) {
            let circleIndex = circleIndices[i];
            let circle = leftHandSingleBassCircles[0][circleIndex];
            circle.classList.remove('active');
          }

          circleIndices = findIndicesOfValue(notesInRootRow, note);
          for (let i = 0; i < circleIndices.length; i++) {
            let circleIndex = circleIndices[i];
            let circle = leftHandSingleBassCircles[1][circleIndex];
            circle.classList.remove('active');
          }

          break;

        case ChordChannel:
          
          if (leftHandChordNotesActive.length == 3) {

            // TODO: Recognize multiple chords.
            const chord = getChordTypeAndKey(leftHandChordNotesActive);

            console.log(`LH - Chord type: ${chord.chordType}, Key: ${chord.key}`);

            // Highlight the corresponding circles for the active chord.
            highlightChord(chord.chordType, chord.key, false);
          }

          break;
      }

      updateActiveNotes(channel, note, false);
    }

    function highlightChord(chordType, chordName, isHighlight) {
      let chordRow = chordRowMap[chordType];
      if (chordRow == null) {
        return;
      }

      let leftHandButtonRow = chordRow + 3; // Chord buttons start on 4th row. of accordionMidiNotes
      let notesInChordRow = accordionMidiNotes[leftHandButtonRow];

      if (chordName.includes('b') || chordName.includes('#')) {
        chordName = chordName.substring(0, 2);
      } else {
        chordName = chordName.substring(0, 1);
      }

      let circles = leftHandChordCircles[chordRow];
      let circleIndices = findIndicesOfValue(notesInChordRow, chordName);
        for (let i = 0; i < circleIndices.length; i++) {
          let circleIndex = circleIndices[i];
          let circle = circles[circleIndex];
          if (isHighlight) {
            circle.classList.add('active');
          }
          else{
            circle.classList.remove('active');
          }
        }
    }

    function init() {
      let accordion = document.getElementById('accordion');

      const NumRowsPerChannel = [1, 2, 4]; // One row of melody keys, 2 rows of single bass notes, 4 rows of chord buttons.
      for (let channelIndex = 0; channelIndex < 3; channelIndex++) {

        let channel = channels[channelIndex];
        let numCirclesPerRow;

        if (channel === MelodyChannel) {
          // Right-hand keys.
          numCirclesPerRow = accordionMidiNotes[0].length;
        }
        else {
          // Left-hand buttons.
          numCirclesPerRow = accordionMidiNotes[1].length;
        }

        let numRows = NumRowsPerChannel[channelIndex];

        let channelContainer = document.createElement('div');
        channelContainer.classList.add('channel-container');
        accordion.appendChild(channelContainer);

        for (let rowNum = 0; rowNum < numRows; rowNum++) {
          let notesContainer = document.createElement('div');
          notesContainer.classList.add('notes-container');
          channelContainer.appendChild(notesContainer);

          let circlesChannel = [];
          for (let i = 0; i < numCirclesPerRow; i++) {
            let circle = document.createElement('div');
            circle.classList.add('circle');
            circle.dataset.note = i;
            notesContainer.appendChild(circle);
            circlesChannel.push(circle);
          }

          switch (channel) {
            case MelodyChannel:
              rightHandCircles = circlesChannel;
              break;
            case BassChannel:
              leftHandSingleBassCircles[rowNum] = circlesChannel;
              break;
            case ChordChannel:
              leftHandChordCircles[rowNum] = circlesChannel;
              break;
          }
        } // end rowNum
      } // end channel

      // Put the left-hand rows of buttons on a diagonal.
      // Select all rows of circles
      const rows = accordion.querySelectorAll('.notes-container');

      let firstOffset = 8

      // Loop through each row
      for (let i = 2; i < rows.length; i++) {
        const currRow = rows[i];
        curOffset = (i-1)*firstOffset;

        // Set the margin for the current row
        currRow.style.marginLeft = `${curOffset}px`;
      }
    } // end init()

    function getChordTypeAndKey(notes) {
      const sortedNotes = notes.slice().sort((a, b) => a - b);
      const intervals = [sortedNotes[1] - sortedNotes[0], sortedNotes[2] - sortedNotes[1]];

      // Check for major triads with root on bottom.
      if (intervals[0] === 4 && intervals[1] === 3) {
        const rootNote = sortedNotes[0];
        return { chordType: 'major', key: getKey(rootNote) };
      }
      // Check for major triads with root on top.
      else if (intervals[0] === 3 && intervals[1] === 5) {
        // Wrap the highest note back to become the root
        const rootNote = sortedNotes[2];
        return { chordType: 'major', key: getKey(rootNote) };
      }
      // Check for major triads with root on 2nd note.
      else if (intervals[0] === 5 && intervals[1] === 4) {
        const rootNote = sortedNotes[1];
        return { chordType: 'major', key: getKey(rootNote) };
      }
      // Check for minor triads with root on bottom.
      else if (intervals[0] === 3 && intervals[1] === 4) {
        const rootNote = sortedNotes[0];
        return { chordType: 'minor', key: getKey(rootNote) };
      }
      // Check for minor triads with root on top.
      else if (intervals[0] === 4 && intervals[1] === 5) {
        const rootNote = sortedNotes[2];
        return { chordType: 'minor', key: getKey(rootNote) };
      }
      // Check for minor triads with root on 2nd note.
      else if (intervals[0] === 5 && intervals[1] === 3) {
        const rootNote = sortedNotes[1];
        return { chordType: 'minor', key: getKey(rootNote) };
      }
      // Check for dominant 7ths with root on bottom.
      else if (intervals[0] === 4 && intervals[1] === 6) {
        const rootNote = sortedNotes[0];
        return { chordType: 'dominant7th', key: getKey(rootNote) };
      }
      // Check for dominant 7ths with on 2nd note.
      else if (intervals[0] === 2 && intervals[1] === 4) {
        const rootNote = sortedNotes[1];
        return { chordType: 'dominant7th', key: getKey(rootNote) };
      }
      // Check for dominant 7ths with root on top.
      else if (intervals[0] === 6 && intervals[1] === 2) {
        const rootNote = sortedNotes[2];
        return { chordType: 'dominant7th', key: getKey(rootNote) };
      }
      // Check for diminished triads with root on bottom.
      else if (intervals[0] === 3 && intervals[1] === 3) {
        const rootNote = sortedNotes[0];
        return { chordType: 'diminished', key: getKey(rootNote) };
      }
      // Check for diminished triads with root on 2nd note
      else if (intervals[0] === 6 && intervals[1] === 3) {
        const rootNote = sortedNotes[1];
        return { chordType: 'diminished', key: getKey(rootNote) };
      }
      // Check for diminished triads with root on top.
      else if (intervals[0] === 3 && intervals[1] === 6) {
        const rootNote = sortedNotes[2];
        return { chordType: 'diminished', key: getKey(rootNote) };
      }
      else {
        return { chordType: 'unknown', key: null };
      }
    }

    function getChordIntervals(notes) {
      // Sort the notes in ascending order
      notes.sort((a, b) => a - b);

      // Compute the intervals between adjacent notes
      const intervals = [];
      for (let i = 0; i < notes.length - 1; i++) {
        intervals.push(notes[i + 1] - notes[i]);
      }

      return intervals;
    }

    function getKey(rootNote) {
      const noteNames = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
      const octave = Math.floor(rootNote / 12) - 1;
      const noteIndex = rootNote % 12;
      return `${noteNames[noteIndex]}${octave}`;
    }

    function findIndicesOfValue(arr, val) {
      let indices = [];
      for (let i = 0; i < arr.length; i++) {
        if (arr[i] === val) {
          indices.push(i);
        }
      }
      return indices;
    }

    navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
    init();
  </script>
</body>

</html>